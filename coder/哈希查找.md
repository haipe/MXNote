# 哈希查找

## 比较经典的场景：学号查找
### 1、没有明显的数学逻辑来归纳查找因子（学号）
### 2、可以用简单高效的逻辑将查找因子（学号）降维排列，并且是一个趋近线性，不分散的排列集合，这个逻辑过程通常称之为哈希映射
### 3、哈希必定存在冲突，高效的冲突处理逻辑，也是考量哈希效率的重要因素


## 常见的哈希计算方法（哈希映射算法）
### 1、直接哈希函数：取关键字本身，或者简单的线性哈希映射算法；如：按照年龄哈希的时候，将出生日期减去最小的年龄。然后就可以使用[0，）的查找因子区间了。
### 2、数字分析法：将已有的查找因子数字分析（比如：将数字进行位数分析，人为归纳数字的某些规律），从而得到哈希映射算法。
```
例如：对以下数字集合进行哈希存储。
8 1 3 4 5 2 5
8 1 3 5 6 7 8
8 1 3 4 4 7 7
8 1 2 3 8 8 8
9 2 3 5 0 9 5
根据统计可以得到，其中的第四位和第五位组成的数字，相对来说，可以进行线性和较少冲突的哈希映射。因而得到哈希映射算法。
```
### 3、平方取中法：将关键字平方，然后再取中间部分位数作为哈希映射的因子；
```
以关键字的平方值的中间几位作为存储地址。求"关键字的平方值”的目的是"扩大差别”和“贡献均衡”即:关键字的各位都在平方值的中间几位有所贡献，Hash值中应该有各位影子。

取关键字平方后的中间几位为哈希地址。由于一个数的平方的中间几位与这个数的每一位都有关，因而，平方取中法产生冲突的机会相对较小。平方取中法中所取的位数由表长决定。

例： 
    K = 456 , K2 = 456x456=207936，若哈希表的长度m=102，则可取79（中间两位）作为哈希函数值

```
### 4、折叠法：关键字位数较长时，可将关键字分割成位数相等的几部分(最后一 部分位数可以不同) ,取这几部分的叠加和(舍去高位的进位)作为哈希地址。位数由存储地址的位数确定。
```
叠加时有两种方法:
1、移位叠加法，即将每部分的最后一位对齐,然后相加;
2、边界叠加法，即把关键字看作一 纸条，从一-端向另一 -端沿边界逐次折叠,然后对齐相加。

(移位叠加法)                                  (边界叠加法)
    d[r]  d[r-1]  ...... d[1]                   d[r]    d[r-1]  ...... d[1]
    d[2r] d[2r-1] ...... d[r+1]                 d[r+1]  d[r+2]  ...... d[2r]
+)  d[3r] d[3r-1] ...... d[2r+1]            +)  d[3r]   d[3r-1] ...... d[2r+1]
-----------------------------------         -----------------------------------
    S[r]  S[r-1]  ...... S[1]                   S[r]  S[r-1]  ...... S[1]
```
### 5、除留余数法：取关键字被某个不大于哈希表长度m的数p除后的余数作为哈希地址；
```
假如被除数 p=21
关键字      28 35 63 77 105
哈希地址    7  14  0  14  0
ps：p的选择很重要，如果选得不好会产生很多冲突。
```
### 6、随机法（伪随机）：选择一个随机函数，取关键字的随机函数值作为哈希地址；
#### 实际工作中需根据不同的情况采用不同的哈希函数。通常需要考虑的因素有:
1、计算哈希函数所需时间;
2、关键字的长度;
3、哈希表的大小;
4、关键字的分布情况;
5、记录的查找频率。



## 字符串的哈希
### 字符ascii码，二分查找
### 字符串各个字符ascii码求和，后采用除留余数法
### 按位加常数，再求和，再除留余数
```
f(x)=(E x[N-i-1] * 32^i ) % 表长
32的次方，可以减少乘法运算，简化为位移操作。

1、可以所有的位数参与计算
2、选择部分固定位的字符参与计算
```


## 哈希的冲突处理·
### 通过哈嘘函数计算后，有两个元素得到的结果一样，因而冲突
### 冲突无法消灭，只可妥善处理
#### 1、线性探测，解决冲突
```
19, 01, 23, 14, 55, 68, 11, 82, 36
设定哈希函数H(key) = key MOD 11 (表长=11 )

【 采用线性探测再散列处理冲突 】 -----------------

索引      0  1  2  3  4  5  6  7  8  9  10
第一次   |  |  |  |  |  |  |  |  |19|  |  |   [ 19%11=8 ]
第二次   |  |01|  |  |  |  |  |  |19|  |  |   [ 1%11=1 ]
第三次   |  |01|23|  |  |  |  |  |19|  |  |   [ 23%11=1 冲突了，向后探测，(2[当前的哈希结果]+1(查找次数))%11(便于处理超出表长的时候)=2，2号非空，所以放入2号 ]
第四次   |  |01|23|14|  |  |  |  |19|  |  |   [ 14%11=3 ]
第五次   |55|01|23|14|  |  |  |  |19|  |  |   [ 55%11=0 ]
第六次   |55|01|23|14|68|  |  |  |19|  |  |   [ 68%11=2 冲突了，向后探测，(2+1%11=3，3号非空，继续探测，(2+2)%11=4，4号空，所以放入4号 ]
...
...
...
分布     |55|01|23|14|68|11|82|36|19|  |  |
冲突次数 |1 |1 |2 |1 |3 |6 | 2| 5 |1 |


【 若采用二次探测再散列处理冲突 】 -----------------
当出现冲突的时候，把冲突后寻找的次数，进行二次 哈希计算。通过指数跳跃，增加查找范围，减少冲突再冲突的概率，来降低处理冲突的时间
但是这种方法，一般要求存储空间为表长的两倍，避免二次的时候超出空间
19, 01, 23, 14, 55, 68, 11, 82, 36
设定哈希函数H(key) = key MOD 11 (表长=11 )

索引      0  1  2  3  4  5  6  7  8  9  10
第一次   |  |  |  |  |  |  |  |  |19|  |  |   [ 19%11=8 ]
第二次   |  |01|  |  |  |  |  |  |19|  |  |   [ 1%11=1 ]
第三次   |  |01|23|  |  |  |  |  |19|  |  |   [ 23%11=1 冲突了，向后探测，(2[当前的哈希结果]+1(查找次数)^2)%11(便于处理超出表长的时候)=2，2号非空，所以放入2号  ]
第四次   |  |01|23|14|  |  |  |  |19|  |  |   [ 14%11=3 ]
第五次   |55|01|23|14|  |  |  |  |19|  |  |   [ 55%11=0 ]
第六次   |55|01|23|14|  |  |68|  |19|  |  |   [ 68%11=2 冲突了，向后探测，(2+1^2)%11=3，3号非空，继续探测，(2+2^2)%11=6，6号空，所以放入6号 ]
...
...
...
分布     |55|01|23|14|11|82|68|36|19|  |
冲突次数 |1 |1 |2 |1 |3 |1 | 4| 4 |1 |


【 若采用随机数处理冲突,随机数假设为9 】 ---------------------
类似的，再冲突的时候，采用增量为固定的随机数来，扩展冲突查找范围，来降低处理冲突的时间
19, 01, 23, 14, 55, 68, 11, 82, 36
设定哈希函数H(key) = key MOD 11 (表长=11 )

索引      0  1  2  3  4  5  6  7  8  9  10
第一次   |  |  |  |  |  |  |  |  |19|  |  |   [ 19%11=8 ]
第二次   |  |01|  |  |  |  |  |  |19|  |  |   [ 1%11=1 ]
第三次   |  |01|  |  |  |  |  |  |19|  |23|   [ 23%11=1 冲突了，向后探测，(2[当前的哈希结果]+1(查找次数)*9)%11(便于处理超出表长的时候)=10，10号非空，所以放入10号  ]
第四次   |  |01|  |14|  |  |  |  |19|  |23|   [ 14%11=3 ]
第五次   |55|01|  |14|  |  |  |  |19|  |  |   [ 55%11=0 ]
第六次   |55|01|68|14|  |  |  |  |19|  |  |   [ 68%11=2 ]
...
...
...
分布     |55|01|68|14|  |82|36|  |19|11|23|
冲突次数  |1 |1 |1 |1 |  |1 | 5|  |1 |2 |2 |


```
#### 2、再哈希，多次多个哈希方法来确定最终的哈希结果
#### 3、链地址，把所有同样一个哈希结果的结果，用链表存储
#### 4、公共溢出区法，将所有的冲突结果，保存再公共溢出存储表，可以扩展多个溢出区，每个溢出区也用不同的哈希方法
